Following clean architecture

Client				Controller (API)							Service (Application)				Repository (Domain)

Request    ->    	Controller action					->		Service class				->		Repository class
					Validate request DTO structure				Validate Domain business			Call DBContext to save entity
					Map Request DTO to Domain					Perform service logic
					Call application service					Map Domain object to Entity
Response    <-		Map Domain object to Response DTO			Call repository
																Map Entity to Domain

-------------------------------------------------------

Rules:
- Request object (naming - {Operation}{Resource}Request, eg: CreateNoteRequest, operation usually CURD)
	- Should be DTO
	- Only primary types (int, string, bool, etc), so JSON serialise and deserialise correctly
	- Uses Data Annotation for structure validation (https://learn.microsoft.com/en-us/aspnet/mvc/overview/older-versions-1/models-data/validation-with-the-data-annotation-validators-cs)

- Response object (naming - {Operation}{Resource}Response, eg: CreateNoteResponse)
	- Should be DTO
	- Only primary types (int, string, bool, etc), so JSON serialise and deserialise correctly
	- No Data Annotation required
	
- Domain object (naming - {Resource}Domain, eg: NoteDomain)
	- Not a DTO, need constructor
	- Has business rules and operations
	- Always in the valid state once created
	- Using extension methods to map between layer (https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods)
	
- Entity object (naming - {Table}Entity, eg: NoteEntity)
	- Should be DTO
	- Only primary types (int, string, bool, etc), so the database types are mapped correctly
	- Uses Data Annotation for length validation

-------------------------------------------------------

	ToList():
- Materializes into a list the moment its used, acts on the database query right away
- It's eager

	AsEnumerable():
- Does not access the database until you numerate it (Select(...))
- It's lazy

-------------------------------------------------------

Unit testing
MOQ mock and X unit

MOQ Mock Testing - Creates a mock object that behaves however you decide
				 - Theres "Setup" (setting up to get expected result) and "Returns" (the expecting outcome)
				 - ".Object" gives the fake implementations
				 - There are two different types of testing, State and Interaction testing (should use both)

X Unit Testing	 - Use for automated tests
				 - Catch bugs early
				 - Verifies single unit behaviors (unit means method/class/small logic)
				 
-------------------------------------------------------

Monoliphic + Aggregate Root